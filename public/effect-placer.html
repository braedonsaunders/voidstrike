<!DOCTYPE html>
<html>
<head>
  <title>Effect Attachment Placer</title>
  <style>
    body { margin: 0; font-family: monospace; background: #1a1a1a; color: #fff; }
    #container { display: flex; height: 100vh; }
    #viewport { flex: 1; }
    #panel { width: 320px; padding: 15px; background: #252525; overflow-y: auto; }
    h3 { margin: 0 0 10px 0; color: #0af; }
    select, input, button {
      width: 100%; padding: 8px; margin: 5px 0;
      background: #333; border: 1px solid #555; color: #fff;
      font-family: monospace;
    }
    button { background: #0af; color: #000; cursor: pointer; font-weight: bold; }
    button:hover { background: #0cf; }
    .point { background: #333; padding: 10px; margin: 10px 0; border-radius: 4px; }
    .point-header { display: flex; justify-content: space-between; align-items: center; }
    .delete-btn { background: #f44; width: auto; padding: 4px 10px; }
    pre {
      background: #111; padding: 10px; font-size: 11px;
      white-space: pre-wrap; word-break: break-all;
      border: 1px solid #444; max-height: 200px; overflow: auto;
    }
    .coords { color: #0f0; }
    .instructions { font-size: 12px; color: #888; margin: 10px 0; }
  </style>
</head>
<body>
  <div id="container">
    <div id="viewport"></div>
    <div id="panel">
      <h3>Effect Placer</h3>

      <label>Unit:</label>
      <select id="unitSelect">
        <option value="dreadnought">dreadnought</option>
        <option value="valkyrie">valkyrie</option>
        <option value="specter">specter</option>
        <option value="lifter">lifter</option>
        <option value="devastator">devastator</option>
        <option value="colossus">colossus</option>
        <option value="scorcher">scorcher</option>
        <option value="fabricator">fabricator</option>
        <option value="trooper">trooper</option>
        <option value="breacher">breacher</option>
      </select>

      <button id="loadBtn">Load Model</button>

      <div class="instructions">
        <b>Controls:</b><br>
        • Right-drag: Rotate camera<br>
        • Scroll: Zoom<br>
        • Click point + drag: Move XZ<br>
        • Click point + Shift+drag: Move Y<br>
      </div>

      <button id="addPoint">+ Add Attachment Point</button>

      <div id="points"></div>

      <h3 style="margin-top:20px;">Output (copy this)</h3>
      <pre id="output">[]</pre>
      <button id="copyBtn">Copy to Clipboard</button>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    let scene, camera, renderer, controls;
    let currentModel = null;
    let attachmentPoints = [];
    let selectedPoint = null;
    let isDragging = false;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    const planeY = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

    function init() {
      const viewport = document.getElementById('viewport');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      camera = new THREE.PerspectiveCamera(50, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
      camera.position.set(5, 3, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(viewport.clientWidth, viewport.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      viewport.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(5, 10, 5);
      scene.add(dir);

      // Grid
      const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
      scene.add(grid);

      // Axes
      scene.add(new THREE.AxesHelper(3));

      // Arrow showing +X (forward direction)
      const arrowDir = new THREE.Vector3(1, 0, 0);
      const arrow = new THREE.ArrowHelper(arrowDir, new THREE.Vector3(0, 0.1, 0), 2, 0x00ff00, 0.3, 0.2);
      scene.add(arrow);

      // Events
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', onResize);

      document.getElementById('loadBtn').onclick = loadModel;
      document.getElementById('addPoint').onclick = addPoint;
      document.getElementById('copyBtn').onclick = copyOutput;

      animate();
    }

    function loadModel() {
      const unit = document.getElementById('unitSelect').value;
      const path = `/models/units/${unit}_LOD0.glb`;

      if (currentModel) {
        scene.remove(currentModel);
      }

      const loader = new GLTFLoader();
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
      loader.setDRACOLoader(dracoLoader);

      loader.load(path, (gltf) => {
        currentModel = gltf.scene;

        // Normalize size
        const box = new THREE.Box3().setFromObject(currentModel);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 3 / maxDim;
        currentModel.scale.setScalar(scale);

        // Center and ground
        box.setFromObject(currentModel);
        const center = box.getCenter(new THREE.Vector3());
        currentModel.position.x = -center.x;
        currentModel.position.z = -center.z;
        currentModel.position.y = -box.min.y;

        scene.add(currentModel);

        // Clear points
        attachmentPoints.forEach(p => scene.remove(p.mesh));
        attachmentPoints = [];
        updatePointsUI();

        console.log(`Loaded ${unit}, normalized scale: ${scale.toFixed(3)}`);
      }, undefined, (err) => {
        alert('Failed to load model: ' + err.message);
      });
    }

    function addPoint() {
      const geo = new THREE.SphereGeometry(0.1, 16, 16);
      const mat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(0, 0.5, 0);
      scene.add(mesh);

      const point = { mesh, id: Date.now() };
      attachmentPoints.push(point);
      updatePointsUI();
    }

    function removePoint(id) {
      const idx = attachmentPoints.findIndex(p => p.id === id);
      if (idx >= 0) {
        scene.remove(attachmentPoints[idx].mesh);
        attachmentPoints.splice(idx, 1);
        updatePointsUI();
      }
    }

    function updatePointsUI() {
      const container = document.getElementById('points');
      container.innerHTML = '';

      attachmentPoints.forEach((point, i) => {
        const div = document.createElement('div');
        div.className = 'point';
        const pos = point.mesh.position;
        div.innerHTML = `
          <div class="point-header">
            <span>Point ${i + 1}</span>
            <button class="delete-btn" onclick="window.removePoint(${point.id})">X</button>
          </div>
          <div class="coords">x: ${pos.x.toFixed(2)}, y: ${pos.y.toFixed(2)}, z: ${pos.z.toFixed(2)}</div>
        `;
        container.appendChild(div);
      });

      updateOutput();
    }

    window.removePoint = removePoint;

    function updateOutput() {
      const data = attachmentPoints.map(p => ({
        x: Math.round(p.mesh.position.x * 100) / 100,
        y: Math.round(p.mesh.position.y * 100) / 100,
        z: Math.round(p.mesh.position.z * 100) / 100,
        scale: 1.0
      }));
      document.getElementById('output').textContent = JSON.stringify(data, null, 2);
    }

    function copyOutput() {
      const text = document.getElementById('output').textContent;
      navigator.clipboard.writeText(text);
      document.getElementById('copyBtn').textContent = 'Copied!';
      setTimeout(() => document.getElementById('copyBtn').textContent = 'Copy to Clipboard', 1500);
    }

    function onMouseDown(e) {
      if (e.button !== 0) return;

      updateMouse(e);
      raycaster.setFromCamera(mouse, camera);

      const meshes = attachmentPoints.map(p => p.mesh);
      const hits = raycaster.intersectObjects(meshes);

      if (hits.length > 0) {
        selectedPoint = attachmentPoints.find(p => p.mesh === hits[0].object);
        selectedPoint.mesh.material.color.setHex(0x00ff00);
        controls.enabled = false;
        isDragging = true;
      }
    }

    function onMouseMove(e) {
      if (!isDragging || !selectedPoint) return;

      updateMouse(e);
      raycaster.setFromCamera(mouse, camera);

      if (e.shiftKey) {
        // Y movement
        const camRight = new THREE.Vector3();
        camera.getWorldDirection(camRight);
        camRight.y = 0;
        camRight.normalize();
        camRight.cross(new THREE.Vector3(0, 1, 0));

        planeY.setFromNormalAndCoplanarPoint(camRight, selectedPoint.mesh.position);
        const pt = new THREE.Vector3();
        raycaster.ray.intersectPlane(planeY, pt);
        if (pt) {
          selectedPoint.mesh.position.y = Math.max(0, pt.y);
        }
      } else {
        // XZ movement
        plane.constant = -selectedPoint.mesh.position.y;
        const pt = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, pt);
        if (pt) {
          selectedPoint.mesh.position.x = pt.x;
          selectedPoint.mesh.position.z = pt.z;
        }
      }

      updatePointsUI();
    }

    function onMouseUp() {
      if (selectedPoint) {
        selectedPoint.mesh.material.color.setHex(0xff6600);
        selectedPoint = null;
      }
      controls.enabled = true;
      isDragging = false;
    }

    function updateMouse(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function onResize() {
      const viewport = document.getElementById('viewport');
      camera.aspect = viewport.clientWidth / viewport.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(viewport.clientWidth, viewport.clientHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
